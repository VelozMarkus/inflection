BASICS

	Java classes:

	package myjavapackage;
	
	class MyClass1
	{
		String a, b, c, d;
	}
	
	class MyClass2 extends MyClass1
	{
		int e;
	}
	
	Inflection views:
	
	package myinflectpackage;
	
	import myjavapackage.MyClass1;
	import myjavapackage.MyClass2;
	
	taxonomy MyTaxonomy
	{
		default property, composite;
	
		@MyClassAnnotation
		view MyClass1
		{
			@MyAttributeAnnotation( name = "a'" )
			a;
			field discrete b;
			c, d;
		}
		
		view MyClass2
		{
			field d;
			e;
		}
	}

1. Views are declared within taxonomies by naming the associated class; e.g., the "view MyClass1" declaration
   in MyTaxonomy refers to the myjavapackage.MyClass1 class. There may be zero or one views per class per
   taxonomy.
2. View names are automatically created within the taxonomy namespace based on the viewed Java class; e.g., 
   "view MyClass1" results in a view named myinflectpackage.MyTaxonomy.myjavapackage.MyClass1.
3. Taxonomies and views are stored in individual compilation units that are later loaded and linked analogous
   to Java classes. The rules for compilation unit naming follows the Java conventions of assigning directories
   to package names and using the dollar sign ($) to separate inner classes. Thus, the following compilation
   units would be generated by the example above:
   
	myinflectpackage/MyTaxonomy.view
	myinflectpackage/MyTaxonomy/myjavapackage/MyClass1
	myinflectpackage/MyTaxonomy/myjavapackage/MyClass2
   
ATTRIBUTES
   
1. Views may define attributes that refer to either fields or JavaBean properties of the referenced class; e.g.,
   a refers to the JavaBean property a in the referenced class MyClass1.
2. Attributes may specify a field/property modifier to indicate whether the attribute refers to a field or property
   in the referenced class. The default is property, thus MyClass1.a refers to a property and MyClass1.b to a field.
   The field/property modifier affects how the attribute is accessed when running an inflection algorithm.
3. Attributes may specify a composite/discrete modifier to indicate whether the referenced object should be regarded
   as a composite part or as a discrete entity in relation to the view. The default is composite, and thus MyClass1.a
   is seen as a composite part of MyClass1 while MyClass1.b is seen as distinct from MyClass1. This modifier affects
   whether inflection algorithms traverse the whole object (composite) or merely the relationship to the object (discrete).
4. Taxonomies may override the default modifiers by declaring specific defaults; e.g., MyTaxonomy declares the specific
   defaults property and composite. Default modifiers are inherited by any extending taxonomies.
5. Attributes are automatically typed by views that are derived from the referenced fields/properties; e.g., MyClass1.a
   is automatically assigned the view type java.lang.String (not to be confused with the Java class java.lang.String).
6. Multiple attributes may be listed in one declaration; e.g., c and d in MyClass1 are listed together. In this case,
   any specified modifiers are applied to all listed attributes. As mentioned before, the view types are in any case
   automatically derived.
7. Views and attributes may use Java-style annotations; e.g., MyClass1 and MyClass1.a are annotated with MyClassAnnotation
   and MyAttributeAnnotation respectively.
   
VIEW INHERITANCE
   
1. Views have a notion of inheritance that depends on the inheritance relationships defined in the referenced classes;
   the view MyClass1 is understood to inherit from MyClass2 due to the inheritance relationship defined between the
   referenced classes MyClass1 and MyClass2. Analogous to attributes, inheritance relationships are defined by
   relative views types; e.g., the view MyClass2 is defined as extending myjavapackage.MyClass1 rather than
   myinflectpackage.MyTaxonomy.myjavapackage.MyClass1.
2. If the class referred to by a view extends another class, then the taxonomy must also contain a view of that extended
   class. If no explicit declaration of the extended class exists then an empty view of the extended class will be
   automatically generated at compile time.
3. View inheritance is roughly analogous to Java class inheritance; thus, MyClass2 inherits a, b, c and d from MyClass1.
   As in Java, attributes may be overridden by sub-views; e.g., MyClass2.d overrides MyClass1.d. The effect of
   attribute overriding is that the modifiers and annotations of the overriding attribute are taken instead of those of
   the overridden one; e.g., MyClass2.d specifies the field modifier which overrides the property modifier (implicitly)
   specified by MyClass1.d.

TAXONOMY INHERITANCE


	class MyClass1
	{
		String a, b, c, d;
	}
	
	class MyClass2 extends MyClass1
	{
		int e;
	}
	
	taxonomy MyTaxonomy1
	{
		view MyClass1
		{
			a, b;
		}
	}
	
	taxonomy MyTaxonomy2
	{
		view MyClass1
		{
			c, d;
		}
		
		view MyClass2
		{
			e;
		}
	}
	
	taxonomy MyTaxonomy2 extends MyTaxonomy1, MyTaxonomy2
	{
		view MyClass1
		{
			a, d;
		}
	}

1. Taxonomies may inherit from one or more other taxonomies. If a taxonomy does not specify a particular
   super-taxonomy, then that taxonomy implicitly extends the root taxonomy ch.liquidmind.inflection.
   RootTaxonomy which contains views for basic and common types; e.g., MyTaxonomy1 implicitly extends
   RootTaxonomy.
2. Extending taxonomies inherit all views defined in the extended taxonomies; e.g., MyTaxonomy2 inherits
   MyClass1 and MyClass2 from MyTaxonomy1 and MyTaxonomy2. Conflicts in the super-taxonomy hierarchy are
   resolved by the rule that the first view found in the list of extended taxonomies wins, thus:
   MyTaxonomy1.MyClass1 takes precedence over MyTaxonomy2.MyClass1 since MyTaxonomy2 lists MyTaxonomy1
   first in the extends clause.
3. Just as attributes in sub-views may override attributes inherited from super-views, views in sub-
   taxonomies may override views defined in super-taxonomies. E.g., MyTaxonomy2.MyClass1 overrides
   the MyClass1 that is inherited from MyTaxonomy1.

POLYMORPHIC LINKING

Java classes are loaded and linked by the Java class loader at runtime rather than compile time. This is
known as dynamic linking and it is possible because, according to Java's class loading rules, class
references can always be resolved to exactly one unique class instance. Due to inflection's multiple
taxonomy concept, however, views cannot be simply linked once by the view loader. To understand why,
consider this example:

	class MyClass1
	{}
	
	class MyClass2 extends MyClass1
	{}

	taxonomy MyTaxonomy1
	{
		view MyClass1
		{}
		
		view MyClass2
		{}
	}

	taxonomy MyTaxonomy2
	{
		view MyClass1
		{}
	}

In MyTaxonomy1, MyClass2 (implicitly) defines an inheritance relationship to MyClass1. However, depending on
whether we are operating with MyTaxonomy1 or MyTaxonomy2, the MyClass1 in question might be either 
MyTaxonomy1.MyClass1 or MyTaxonomy2.MyClass1. Therefore, MyClass2 cannot be linked to either of the MyClass1
views until the taxonomic context is known. This is analogous to dynamic invocation in Java where the invoker
doesn't know the location of the actual method to invoke until runtime (when the object type is known).

EXAMPLE

taxonomy BaseTaxonomy
{
	view Person
	{
		firstName, lastName;
	}

	view Address
	{
		street, zip, city, country;
	}

	view Employer
	{
		jobProfile;
	}

	view JobProfile
	{
		passionSkills;
	}

	view PassionSkills
	{}
}

taxonomy ConcatPersonTaxonomy extends BaseTaxonomy
{
	view Person
	{
		fullName;
	}
}

taxonomy ConcatAddressTaxonomy extends BaseTaxonomy
{
	view Address
	{
		fullAddress;
	}
}

taxonomy ConcatAllTaxonomy extends ConcatPersonTaxonomy, ConcatAddressTaxonomy
{}

taxonomy MatchingTaxonomy extends BaseTaxonomy
{
	view Employer
	{}

	view JobProfile
	{
		employer, passionSkills;
	}
}